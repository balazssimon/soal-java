/*
 * generated by Xtext 2.31.0
 */
package soal.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import soal.dsl.services.SoalDslGrammarAccess;
import soal.model.ContainmentArrayType;
import soal.model.EnumLiteral;
import soal.model.EnumType;
import soal.model.Interface;
import soal.model.NullableType;
import soal.model.Operation;
import soal.model.ParameterList;
import soal.model.Property;
import soal.model.ReferenceArrayType;
import soal.model.Resource;
import soal.model.Service;
import soal.model.SimpleTypeReference;
import soal.model.SoalModel;
import soal.model.SoalModelPackage;
import soal.model.StructType;

@SuppressWarnings("all")
public class SoalDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SoalDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SoalModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SoalModelPackage.CONTAINMENT_ARRAY_TYPE:
				sequence_ArrayType(context, (ContainmentArrayType) semanticObject); 
				return; 
			case SoalModelPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case SoalModelPackage.ENUM_TYPE:
				sequence_EnumDeclaration(context, (EnumType) semanticObject); 
				return; 
			case SoalModelPackage.INTERFACE:
				sequence_InterfaceDeclaration(context, (Interface) semanticObject); 
				return; 
			case SoalModelPackage.NULLABLE_TYPE:
				sequence_NullableType(context, (NullableType) semanticObject); 
				return; 
			case SoalModelPackage.OPERATION:
				sequence_OperationDeclaration(context, (Operation) semanticObject); 
				return; 
			case SoalModelPackage.PARAMETER:
				if (rule == grammarAccess.getParameterRule()) {
					sequence_Parameter(context, (soal.model.Parameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleReturnParameterRule()) {
					sequence_SingleReturnParameter(context, (soal.model.Parameter) semanticObject); 
					return; 
				}
				else break;
			case SoalModelPackage.PARAMETER_LIST:
				if (rule == grammarAccess.getInputParameterListRule()) {
					sequence_InputParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOutputParameterListRule()) {
					sequence_OutputParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else break;
			case SoalModelPackage.PROPERTY:
				sequence_FieldDeclaration(context, (Property) semanticObject); 
				return; 
			case SoalModelPackage.REFERENCE_ARRAY_TYPE:
				sequence_ArrayType(context, (ReferenceArrayType) semanticObject); 
				return; 
			case SoalModelPackage.RESOURCE:
				sequence_ResourceDeclaration(context, (Resource) semanticObject); 
				return; 
			case SoalModelPackage.SERVICE:
				sequence_ServiceDeclaration(context, (Service) semanticObject); 
				return; 
			case SoalModelPackage.SIMPLE_TYPE_REFERENCE:
				sequence_SimpleTypeReference(context, (SimpleTypeReference) semanticObject); 
				return; 
			case SoalModelPackage.SOAL_MODEL:
				sequence_SoalModel(context, (SoalModel) semanticObject); 
				return; 
			case SoalModelPackage.STRUCT_TYPE:
				sequence_StructDeclaration(context, (StructType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReference returns ContainmentArrayType
	 *     ArrayType returns ContainmentArrayType
	 *
	 * Constraint:
	 *     innerType=NullableType
	 * </pre>
	 */
	protected void sequence_ArrayType(ISerializationContext context, ContainmentArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.CONTAINMENT_ARRAY_TYPE__INNER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.CONTAINMENT_ARRAY_TYPE__INNER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getInnerTypeNullableTypeParserRuleCall_1_1_0(), semanticObject.getInnerType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReference returns ReferenceArrayType
	 *     ArrayType returns ReferenceArrayType
	 *
	 * Constraint:
	 *     innerType=[Type|SimpleTypeName]
	 * </pre>
	 */
	protected void sequence_ArrayType(ISerializationContext context, ReferenceArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.REFERENCE_ARRAY_TYPE__INNER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.REFERENCE_ARRAY_TYPE__INNER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getInnerTypeTypeSimpleTypeNameParserRuleCall_0_1_0_1(), semanticObject.eGet(SoalModelPackage.Literals.REFERENCE_ARRAY_TYPE__INNER_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns EnumType
	 *     EnumDeclaration returns EnumType
	 *
	 * Constraint:
	 *     (name=ID (literals+=EnumLiteral literals+=EnumLiteral*)?)
	 * </pre>
	 */
	protected void sequence_EnumDeclaration(ISerializationContext context, EnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldDeclaration returns Property
	 *
	 * Constraint:
	 *     (typeReference=TypeReference name=ID)
	 * </pre>
	 */
	protected void sequence_FieldDeclaration(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE));
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldDeclarationAccess().getTypeReferenceTypeReferenceParserRuleCall_0_0(), semanticObject.getTypeReference());
		feeder.accept(grammarAccess.getFieldDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=Parameter parameters+=Parameter*)?
	 * </pre>
	 */
	protected void sequence_InputParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Interface
	 *     InterfaceDeclaration returns Interface
	 *
	 * Constraint:
	 *     (name=ID resources+=ResourceDeclaration* operations+=OperationDeclaration*)
	 * </pre>
	 */
	protected void sequence_InterfaceDeclaration(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReference returns NullableType
	 *     NullableType returns NullableType
	 *
	 * Constraint:
	 *     innerType=[Type|SimpleTypeName]
	 * </pre>
	 */
	protected void sequence_NullableType(ISerializationContext context, NullableType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.NULLABLE_TYPE__INNER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.NULLABLE_TYPE__INNER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullableTypeAccess().getInnerTypeTypeSimpleTypeNameParserRuleCall_0_0_1(), semanticObject.eGet(SoalModelPackage.Literals.NULLABLE_TYPE__INNER_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OperationDeclaration returns Operation
	 *
	 * Constraint:
	 *     (
	 *         async?='async'? 
	 *         responseParameters=OutputParameterList 
	 *         name=ID 
	 *         requestParameters=InputParameterList 
	 *         (exceptions+=[StructType|ID] exceptions+=[StructType|ID]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_OperationDeclaration(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=SingleReturnParameter | (parameters+=Parameter parameters+=Parameter*))?
	 * </pre>
	 */
	protected void sequence_OutputParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (typeReference=TypeReference name=ID)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, soal.model.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE));
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeReferenceTypeReferenceParserRuleCall_0_0(), semanticObject.getTypeReference());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceDeclaration returns Resource
	 *
	 * Constraint:
	 *     (readonly?='readonly'? entity=[StructType|ID] (exceptions+=[StructType|ID] exceptions+=[StructType|ID]*)?)
	 * </pre>
	 */
	protected void sequence_ResourceDeclaration(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Service
	 *     ServiceDeclaration returns Service
	 *
	 * Constraint:
	 *     (name=ID interface=[Interface|ID] (binding=RestBindingKind | binding=SoapBindingKind))
	 * </pre>
	 */
	protected void sequence_ServiceDeclaration(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeReference returns SimpleTypeReference
	 *     SimpleTypeReference returns SimpleTypeReference
	 *
	 * Constraint:
	 *     referencedType=[Type|SimpleTypeName]
	 * </pre>
	 */
	protected void sequence_SimpleTypeReference(ISerializationContext context, SimpleTypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.SIMPLE_TYPE_REFERENCE__REFERENCED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.SIMPLE_TYPE_REFERENCE__REFERENCED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTypeReferenceAccess().getReferencedTypeTypeSimpleTypeNameParserRuleCall_0_1(), semanticObject.eGet(SoalModelPackage.Literals.SIMPLE_TYPE_REFERENCE__REFERENCED_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SingleReturnParameter returns Parameter
	 *
	 * Constraint:
	 *     typeReference=TypeReference
	 * </pre>
	 */
	protected void sequence_SingleReturnParameter(ISerializationContext context, soal.model.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SoalModelPackage.Literals.TYPED_ELEMENT__TYPE_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleReturnParameterAccess().getTypeReferenceTypeReferenceParserRuleCall_0(), semanticObject.getTypeReference());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SoalModel returns SoalModel
	 *
	 * Constraint:
	 *     (name=ID imports+=[SoalModel|STRING]* declarations+=Declaration*)
	 * </pre>
	 */
	protected void sequence_SoalModel(ISerializationContext context, SoalModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns StructType
	 *     StructDeclaration returns StructType
	 *
	 * Constraint:
	 *     (name=ID baseType=[StructType|ID]? fields+=FieldDeclaration*)
	 * </pre>
	 */
	protected void sequence_StructDeclaration(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
